from fastapi import FastAPI, HTTPException, Query
from typing import List, Optional
from pydantic import BaseModel
from youtube_transcript_api import YouTubeTranscriptApi
from youtube_transcript_api.proxies import WebshareProxyConfig
import os
from pathlib import Path


class Segment(BaseModel):
    start: str
    text: str


class TranscriptResponse(BaseModel):
    video_id: str
    segments: List[Segment]
    total_duration: str


def _seconds_to_hms(seconds: float) -> str:
    s = int(round(seconds))
    h = s // 3600
    m = (s % 3600) // 60
    sec = s % 60
    return f"{h:02d}:{m:02d}:{sec:02d}"


def _aggregate_segments(raw_segments: List[dict], min_duration: float = 10.0) -> List[dict]:
    if not raw_segments:
        return []
    # Ensure segments are sorted by start time
    segs = sorted(raw_segments, key=lambda s: s.get("start", 0))
    aggregated = []
    i = 0
    n = len(segs)
    while i < n:
        cur_start = segs[i]["start"]
        cur_duration = 0.0
        texts = []
        while i < n and cur_duration < min_duration:
            seg = segs[i]
            cur_duration += float(seg.get("duration", 0.0))
            texts.append(seg.get("text", "").strip())
            i += 1
        aggregated.append(
            {
                "start": _seconds_to_hms(cur_start),
                "text": " ".join(t for t in texts if t),
            }
        )
    return aggregated


app = FastAPI(
    title="YouTube Transcript Service",
    version="1.0.0",
    docs_url="/api/v1/docs",
    redoc_url="/api/v1/redoc",
    openapi_url="/api/v1/openapi.json",
)


# Load secrets from a .secrets file in the repository root (if present)
def _load_secrets_file(path: Path):
    if not path.is_file():
        return
    for line in path.read_text().splitlines():
        line = line.strip()
        if not line or line.startswith("#"):
            continue
        if "=" in line:
            k, v = line.split("=", 1)
            os.environ.setdefault(k.strip(), v.strip())

secrets_path = Path(__file__).resolve().parents[1] / ".secrets"
_load_secrets_file(secrets_path)

proxy_username = os.environ.get("PROXY_USERNAME")
proxy_password = os.environ.get("PROXY_PASSWORD")

if proxy_username and proxy_password:
    ytt_api = YouTubeTranscriptApi(
        proxy_config=WebshareProxyConfig(
            proxy_username=proxy_username,
            proxy_password=proxy_password,
        )
    )
else:
    ytt_api = YouTubeTranscriptApi()

@app.get("/api/v1/health")
def health():
    return {"status": "ok", "service": "youtube-transcript-service", "version": "1.0.0"}


@app.get("/api/v1/transcript_example", response_model=TranscriptResponse)
def transcript_example():
    """Return a small example transcript response (useful for docs/tests)."""
    raw_segments = [
        {"start": 0.0, "duration": 3.0, "text": "alpha"},
        {"start": 3.0, "duration": 4.0, "text": "beta"},
        {"start": 7.0, "duration": 5.0, "text": "gamma"},
        {"start": 12.0, "duration": 2.0, "text": "delta"},
    ]
    total_secs = 0.0
    if raw_segments:
        total_secs = max((s.get("start", 0.0) + float(s.get("duration", 0.0))) for s in raw_segments)
    total_duration = _seconds_to_hms(total_secs)
    segments = _aggregate_segments(raw_segments, min_duration=10.0)
    return {"video_id": "example", "segments": segments, "total_duration": total_duration}


@app.get("/api/v1/transcript", response_model=TranscriptResponse)
def get_transcript(
    video_id: str = Query(..., description="YouTube video ID, e.g. dQw4w9WgXcQ"),
    languages: Optional[str] = Query(None, description="Comma-separated languages in priority order, e.g. en,fr"),
):
    if not video_id:
        raise HTTPException(status_code=400, detail="video_id query parameter is required")

    # Parse languages: accept comma-separated string or default to ['en']
    if languages:
        langs = [l.strip() for l in languages.split(",") if l.strip()]
        if not langs:
            langs = ["en"]
    else:
        langs = ["en"]

    try:
        transcript = ytt_api.fetch(video_id, languages=langs)
        # Convert FetchedTranscript to raw list of dicts
        segments_raw = transcript.to_raw_data()
        total_secs = 0.0
        if segments_raw:
            total_secs = max((s.get("start", 0.0) + float(s.get("duration", 0.0))) for s in segments_raw)
        total_duration = _seconds_to_hms(total_secs)
        segments = _aggregate_segments(segments_raw, min_duration=10.0)
    except Exception:
        # Try a relaxed fallback (no language preference) which can fetch autogenerated captions
        try:
            transcript = ytt_api.fetch(video_id)
            segments_raw = transcript.to_raw_data()
            total_secs = 0.0
            if segments_raw:
                total_secs = max((s.get("start", 0.0) + float(s.get("duration", 0.0))) for s in segments_raw)
            total_duration = _seconds_to_hms(total_secs)
            segments = _aggregate_segments(segments_raw, min_duration=10.0)
        except Exception as e:
            raise HTTPException(status_code=404, detail=f"Transcript not available for video ID {video_id}: {e}")

    return {"video_id": video_id, "segments": segments, "total_duration": total_duration}


if __name__ == "__main__":
    import uvicorn

    uvicorn.run("app.main:app", host="0.0.0.0", port=8000)
